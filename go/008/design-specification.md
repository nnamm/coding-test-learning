### 机上設計

1. 入力値読み取り（木構造データ管理）

- 入力されたノード数nを取得。（fmt.Scanのエラー判定を実施、入力不正時は何もせず終了）
- ノード数分、以下を実施。
  - ノード情報（ノード番号 左の子 右の子）を取得。
  - map型の`nodeChildren`に格納。（Key: ノード番号、Value:左の子、右の子）

2. 木構造走査

- メイン処理にて以下を実施。
  - 関数：前順走査（preOrder）をコール。引数は「ルートノード番号（1）」と「nodeChildren」。
  - 関数：中順走査（inOrder）をコール。引数は「ルートノード番号（1）」と「nodeChildren」。
  - 関数：後順走査（postOrder）をコール。引数は「ルートノード番号（1）」と「nodeChildren」。

3. 関数：前順走査の処理

- 現在のノードが存在するかチェック。
  - ノードが存在する場合（-1以外）、現在のノードを出力
  - ノードが存在しない場合（-1）、処理を終了
- 左の子ノードに対して同じ処理を再帰的に実行。
- 右の子ノードに対して同じ処理を再帰的に実行。

4. 関数：中順走査の処理

- 左の子ノードに対して同じ処理を再帰的に実行。
- 現在のノードが存在するかチェック。
  - ノードが存在する場合（-1以外）、現在のノードを出力
  - ノードが存在しない場合（-1）、処理を終了
- 右の子ノードに対して同じ処理を再帰的に実行。
- ※現在のノードが存在するかチェックについては関数の最初に実施すること（前順走査と同様）

5. 関数：後順走査の処理

- 左の子ノードに対して同じ処理を再帰的に実行。
- 右の子ノードに対して同じ処理を再帰的に実行。
- 現在のノードが存在するかチェック。
  - ノードが存在する場合（-1以外）、現在のノードを出力
  - ノードが存在しない場合（-1）、処理を終了
- ※現在のノードが存在するかチェックについては関数の最初に実施すること（前順走査と同様）

### MEMO

- 再帰処理はベースケース（終了条件）を最初に書く。基本原則。
