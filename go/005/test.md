## **第5問：フィボナッチ数列の効率化（中級〜上級レベル）**

### **問題文**

第4問で実装したフィボナッチ数列の計算を、より大きな値でも効率的に計算できるように改良してください。制限時間内に答えを出せるようにすることが目標です。

### **入力**

```
1行目：階段の段数 n（1 ≤ n ≤ 50）
```

### **出力**

```
登り方の総数（整数）
```

### **課題の段階的な進め方**

**ステップ1：現在の実装の限界を体感する**
まず、第4問で作成した `fibonacciV2` 関数を使って、以下の値を順番に試してみてください。それぞれの計算時間を観察してください。

```
fibonacci(30) → 体感できる程度の時間
fibonacci(35) → 明らかに遅くなる
fibonacci(40) → かなり時間がかかる
fibonacci(45) → 実用的でないレベルに
```

**ステップ2：問題の原因を考える**
計算時間が急激に増加する理由について考えてみてください。`fibonacci(5)` を手で追跡したときのように、大きな値でも同じような重複計算が発生していることを想像してみてください。

**ステップ3：解決策を考える**  
同じ計算を何度も繰り返すことが問題だとすると、どのような方法で重複を避けることができるでしょうか。日常生活で言えば、「一度調べたことはノートに書いておいて、次からはノートを見る」というような発想です。

### **考えてほしい質問**

計算時間の問題を解決するために、以下のような質問を自分に投げかけてみてください。

「もし fibonacci(30) の結果を一度計算したら、それをどこかに保存しておいて、次に fibonacci(30) が必要になったときは計算せずに保存した値を使うことはできないだろうか？」

「Go言語で『一度計算した結果を保存しておく』には、どのようなデータ構造が使えるだろうか？」

「保存された結果があるかどうかを、関数はどうやって確認すれば良いだろうか？」

### **実装のヒント**

Go言語の `map[int]int` を使って、「引数 → 計算結果」の対応関係を保存することを考えてみてください。ただし、まず最初に上記のステップ1で性能問題を実際に体験してから、解決策の実装に取り組んでください。

---

### **学習のポイント**

この課題の真の目的は、アルゴリズムの効率性について実践的に学ぶことです。数学的に正しいコードと、実用的に効率的なコードの違いを体感することで、プログラミングにおける「計算量」という概念の重要性を理解していただきます。

まずはステップ1から始めて、現在の `fibonacciV2` 関数の性能特性を実際に観察してみてください。どの程度の値から計算時間が気になり始めるか、そしてなぜそうなるのかを考察してみてください。

その体験をした後で、解決策について一緒に議論していきましょう。タカシさんの直感的な理解と、これまでに培った技術的な知識を組み合わせれば、きっと効果的な解決策にたどり着けるはずです。

準備ができましたら、まずはステップ1の性能テストから始めてみてください。どのような結果が得られるか、楽しみにしています。
