## MEMO

- DFSは全探索が基本となる。二次元Gridならば計算量はO(H x W)となる。
- 本課題のテーマは深度優先探索ではあるが、効率的に目的地に着くようなアルゴリズムではなく、愚直な総当たりです。
- スタックで実現可能だが、再帰にすることでコード上はシンプルになる。（今回は再帰で実装する想定）
- 現代的コーディングにおける再帰の理解が必要。（JAL時代でもやってはいたが、記述が異なる）

## 机上設計

1. 入力値読み取り（地形データの作成）

- 入力された行と列の数を取得。（fmt.Scanのエラー判定を実施、入力不正時は何もせず終了）
- 行の数からスライス生成。
- 列の数のからスライス生成。（NewscannerとScanを用いて地形データを作成、入力が不足している場合は水'0'を補完）
- スライス名はgrid

2. DFS用データ構造の初期化

- 訪問済みフラグ（visited [][]bool）の二次元配列の初期化。
- 上下左右の移動方向（directions [4][2]int）の初期化。
- 島数（islandCount int）の初期化。

3. DFS処理本体

- 外層処理（メインループ）
  - すべてのgridを順番にスキャンする。
  - 未訪問の陸地'1'を発見したら内層処理（dfsExploreIsland関数）を呼び出す。
  - 内層処理が返ってきたら島探索は完了とし、島数をインクリメント。
- 内層処理（dfsExploreIsland関数）
  - 指定されたgridから開始して、移動方向（上下左右）ごとに以下の処理を実施。
    - 訪問済みgridをtrueを設定。
    - 移動可否判定（gridが境界内であること && 島'1' であること && 訪問済みでないこと）
    - 移動可ならgridを1つずらして、再起的に探索処理を実行。
    - 移動不可なら次の移動方向の処理を実施。

4. 島探索結果出力

- 島数を出力。
