## 【第6問：迷路の最短経路探索（幅優先探索導入）】

### 問題設定

二次元の迷路が与えられます。迷路は以下のような形式で表現されます：

- `0`: 通れる道
- `1`: 壁（通れない）
- `S`: スタート地点
- `G`: ゴール地点

スタート地点からゴール地点までの最短距離（歩数）を求めてください。ゴールに到達できない場合は `-1` を返してください。

### 入力形式

```
4 5
S0001
01010
00001
1000G
```

1行目：迷路の縦の大きさ H、横の大きさ W（1 ≤ H, W ≤ 20）
2行目以降：迷路の情報（H行W列）

### 出力形式

```
7
```

最短距離を整数で出力してください。

### 解法のヒント

この問題では「幅優先探索（BFS: Breadth-First Search）」という手法を使います。BFSの特徴を説明しますね。

**BFSの基本概念**：

- 現在地点から到達可能な全ての隣接地点を「同時に」探索する
- 距離1の地点をすべて探索してから、距離2の地点を探索する
- そのため、最初にゴールに到達した時点で、それが最短経路となる

**必要なデータ構造**：

- **キュー（Queue）**: 次に探索する地点を管理する（FIFO: First In, First Out）
- **visited配列**: 既に訪問した地点を記録し、無限ループを防ぐ

**アルゴリズムの流れ**：

1. スタート地点をキューに追加
2. キューが空でない限り以下を繰り返す：
   - キューから地点を取り出す
   - その地点がゴールなら距離を返す
   - 上下左右の隣接地点を調べ、通れる未訪問地点をキューに追加

### Go言語での実装ポイント

```go
// 地点を表す構造体
type Point struct {
    row, col, distance int
}

// キューをスライスで実装
queue := []Point{}
queue = append(queue, startPoint) // enqueue
point := queue[0]; queue = queue[1:] // dequeue
```

**時間目標**: 45分以内での完成を目指してください。

それでは実装に取り組んでみてください！BFSは多くの問題に応用できる重要なアルゴリズムです。迷路探索の他にも、ネットワークの最短経路、木構造の走査など、実際のシステム開発でも頻繁に使われる手法です。

実装が完了したら、コードをお見せください。良い点と改善点、そしてBFSの理解度について詳しくレビューさせていただきます！
